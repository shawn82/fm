<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FongMi TV ç›‘æ§é¢æ¿</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .input-group {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        @media (max-width: 600px) {
            .input-group {
                grid-template-columns: 1fr;
            }
        }

        .input-group input {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
            min-height: 42px;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .progress-bar-scan {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        .devices-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }

        .device-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }

        .device-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 12px rgba(0,0,0,0.15);
        }

        .device-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            padding-right: 40px;
            border-bottom: 2px solid #f0f0f0;
            position: relative;
        }

        .device-ip {
            font-size: 18px;
            font-weight: 700;
            color: #667eea;
            flex-shrink: 0;
        }

        .device-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .status-online {
            background: #d4edda;
            color: #155724;
        }

        .video-title {
            font-size: 20px;
            font-weight: 700;
            color: #333;
            margin: 10px 0;
        }

        .video-title.idle {
            color: #ccc;
            font-style: italic;
        }

        .video-meta {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 10px 0;
        }

        .meta-item {
            padding: 4px 10px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 13px;
            color: #666;
        }

        .info-row {
            margin: 8px 0;
            font-size: 13px;
            color: #666;
        }

        .remove-btn {
            position: absolute;
            top: 0;
            right: 0;
            background: rgba(244, 67, 54, 0.1);
            border: none;
            color: #f44336;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            line-height: 32px;
            text-align: center;
            z-index: 10;
        }

        .remove-btn:hover {
            background: #f44336;
            color: white;
        }

        .no-devices {
            grid-column: 1 / -1;
            text-align: center;
            padding: 60px 20px;
            background: white;
            border-radius: 12px;
            color: #666;
        }

        .tip-box {
            margin-top: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¬ FongMi TV ç›‘æ§</h1>
            <p>å®æ—¶æ˜¾ç¤º TV Box æ’­æ”¾å†…å®¹</p>
            <div id="protocolWarning" style="display: none; margin-top: 10px; padding: 10px; background: #fff3cd; color: #856404; border-radius: 8px; font-size: 14px;">
                âš ï¸ æ£€æµ‹åˆ°æœ¬åœ°æ–‡ä»¶è®¿é—®æ¨¡å¼ï¼Œåˆ·æ–°åŠŸèƒ½å¯èƒ½æ— æ³•ä½¿ç”¨ã€‚<br>
                å»ºè®®ï¼šå°†æ­¤æ–‡ä»¶æ”¾åˆ° HTTP æœåŠ¡å™¨ä¸Šè®¿é—®
            </div>
        </div>

        <div class="controls">
            <div class="input-group">
                <input type="text" id="ipInput" placeholder="è¾“å…¥IPåœ°å€ (é€‰å¡«ï¼Œç•™ç©ºæ‰«æ 192.168.0.x)">
                <button class="btn btn-primary" id="addBtn">â• æ·»åŠ </button>
                <button class="btn btn-primary" id="scanBtn">ğŸ” æ‰«æ</button>
            </div>
            <div id="statusMsg"></div>
        </div>

        <div class="devices-grid" id="devicesGrid">
            <div class="no-devices">
                <div style="font-size: 64px; margin-bottom: 20px;">ğŸ“º</div>
                <h3>è¿˜æ²¡æœ‰æ·»åŠ è®¾å¤‡</h3>
                <p>ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®æ¥æ·»åŠ æˆ–æ‰«æè®¾å¤‡</p>
            </div>
        </div>
    </div>

    <script>
        const devices = new Map();
        const websockets = new Map();
        let isScanning = false;

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type = 'info', progress = null) {
            const statusMsg = document.getElementById('statusMsg');
            statusMsg.className = `status ${type}`;
            
            if (progress !== null) {
                statusMsg.innerHTML = `
                    ${message}
                    <div class="progress-bar-scan">
                        <div class="progress-fill" style="width: ${progress}%"></div>
                    </div>
                `;
            } else {
                statusMsg.innerHTML = message;
            }
        }

        // æ·»åŠ è®¾å¤‡
        function addDevice() {
            const ipInput = document.getElementById('ipInput');
            let ip = ipInput.value.trim();
            
            console.log('æ·»åŠ è®¾å¤‡:', ip);
            
            if (!ip) {
                showStatus('âŒ è¯·è¾“å…¥IPåœ°å€', 'error');
                return;
            }
            
            ip = ip.replace(/\s+/g, '');
            
            const ipPattern = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
            const match = ip.match(ipPattern);
            
            if (!match) {
                showStatus('âŒ IPæ ¼å¼ä¸æ­£ç¡®', 'error');
                return;
            }
            
            for (let i = 1; i <= 4; i++) {
                const num = parseInt(match[i]);
                if (num < 0 || num > 255) {
                    showStatus('âŒ IPæ•°å­—å¿…é¡»åœ¨0-255ä¹‹é—´', 'error');
                    return;
                }
            }
            
            if (devices.has(ip)) {
                showStatus('âš ï¸ è®¾å¤‡å·²å­˜åœ¨', 'error');
                return;
            }
            
            devices.set(ip, {
                ip: ip,
                connected: false,
                title: null,
                remarks: null,
                year: null,
                area: null,
                vodClass: null,
                actor: null,
                director: null,
                currentEpisode: null,
                lastUpdate: new Date()
            });
            
            connectWebSocket(ip);
            renderDevices();
            // æ·»åŠ åä¸æ¸…ç©ºè¾“å…¥æ¡†ï¼Œæ–¹ä¾¿æ‰«æ
            // ipInput.value = '';
            showStatus(`âœ… å·²æ·»åŠ  ${ip}`, 'success');
        }

        // è¿æ¥WebSocket
        function connectWebSocket(ip) {
            if (window.location.protocol === 'https:') {
                showStatus('âŒ HTTPSé¡µé¢æ— æ³•è¿æ¥ï¼Œè¯·ä½¿ç”¨HTTPè®¿é—®', 'error');
                return;
            }
            
            console.log(`è¿æ¥ ${ip}`);
            
            try {
                const ws = new WebSocket(`ws://${ip}:9978`);
                
                ws.onopen = () => {
                    console.log(`âœ… ${ip} è¿æ¥æˆåŠŸ`);
                    updateDevice(ip, { connected: true });
                    
                    setInterval(() => {
                        if (ws.readyState === WebSocket.OPEN) {
                            ws.send('HEARTBEAT');
                        }
                    }, 1000);
                };

                ws.onmessage = (event) => {
                    if (event.data !== 'HEARTBEAT') {
                        parseMessage(ip, event.data);
                    }
                };

                ws.onerror = (error) => {
                    console.error(`âŒ ${ip} è¿æ¥é”™è¯¯`);
                    updateDevice(ip, { connected: false });
                };

                ws.onclose = () => {
                    console.log(`ğŸ”Œ ${ip} æ–­å¼€`);
                    updateDevice(ip, { connected: false });
                    setTimeout(() => {
                        if (devices.has(ip)) {
                            connectWebSocket(ip);
                        }
                    }, 5000);
                };

                websockets.set(ip, ws);
            } catch (error) {
                console.error(`è¿æ¥å¤±è´¥: ${ip}`, error);
            }
        }

        // è§£ææ¶ˆæ¯
        function parseMessage(ip, message) {
            const device = devices.get(ip);
            if (!device) return;

            let updated = false;

            // æå–è§†é¢‘ä¿¡æ¯
            if (message.includes('vod_name')) {
                const nameMatch = message.match(/"vod_name":"([^"]+)"/);
                const remarksMatch = message.match(/"vod_remarks":"([^"]*)"/);
                const yearMatch = message.match(/"vod_year":"([^"]*)"/);
                const areaMatch = message.match(/"vod_area":"([^"]*)"/);
                const classMatch = message.match(/"vod_class":"([^"]*)"/);
                const actorMatch = message.match(/"vod_actor":"([^"]*)"/);
                const directorMatch = message.match(/"vod_director":"([^"]*)"/);
                
                if (nameMatch) {
                    // æ¸…ç©ºä¹‹å‰çš„é›†æ•°ä¿¡æ¯ï¼ˆå› ä¸ºæ˜¯æ–°è§†é¢‘ï¼‰
                    device.currentEpisode = null;
                    
                    device.title = nameMatch[1];
                    device.remarks = remarksMatch ? remarksMatch[1] : null;
                    device.year = yearMatch ? yearMatch[1] : null;
                    device.area = areaMatch ? areaMatch[1] : null;
                    device.vodClass = classMatch ? classMatch[1] : null;
                    device.actor = actorMatch ? actorMatch[1] : null;
                    device.director = directorMatch ? directorMatch[1] : null;
                    console.log(`${ip}: ${device.title}`);
                    updated = true;
                }
            }
            
            // æå–é›†æ•° - åªæœ‰åœ¨æœ‰æ˜ç¡®é›†æ•°æ ‡è®°æ—¶æ‰æ›´æ–°
            if (message.includes('ç¬¬') && message.includes('é›†')) {
                const episodeMatch = message.match(/ç¬¬0*(\d+)é›†/);
                if (episodeMatch) {
                    const newEpisode = episodeMatch[1];
                    // åªæœ‰å½“é›†æ•°å‘ç”Ÿå˜åŒ–æ—¶æ‰æ›´æ–°
                    if (device.currentEpisode !== newEpisode) {
                        device.currentEpisode = newEpisode;
                        console.log(`${ip}: ç¬¬${device.currentEpisode}é›†`);
                        updated = true;
                    }
                }
            } else if (message.includes('%E7%AC%AC') && message.includes('%E9%9B%86')) {
                // URLç¼–ç çš„é›†æ•°
                const episodeMatch = message.match(/%E7%AC%AC0*(\d+)%E9%9B%86/);
                if (episodeMatch) {
                    const newEpisode = episodeMatch[1];
                    if (device.currentEpisode !== newEpisode) {
                        device.currentEpisode = newEpisode;
                        console.log(`${ip}: ç¬¬${device.currentEpisode}é›†`);
                        updated = true;
                    }
                }
            }

            if (updated) {
                device.lastUpdate = new Date();
                renderDevices();
            }
        }

        // æ›´æ–°è®¾å¤‡
        function updateDevice(ip, updates) {
            const device = devices.get(ip);
            if (device) {
                Object.assign(device, updates);
                device.lastUpdate = new Date();
                renderDevices();
            }
        }

        // æ¸²æŸ“è®¾å¤‡
        function renderDevices() {
            const grid = document.getElementById('devicesGrid');
            
            if (devices.size === 0) {
                grid.innerHTML = `
                    <div class="no-devices">
                        <div style="font-size: 64px; margin-bottom: 20px;">ğŸ“º</div>
                        <h3>è¿˜æ²¡æœ‰æ·»åŠ è®¾å¤‡</h3>
                        <p>ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®æ¥æ·»åŠ æˆ–æ‰«æè®¾å¤‡</p>
                    </div>
                `;
                return;
            }

            grid.innerHTML = '';
            
            devices.forEach((device, ip) => {
                const card = document.createElement('div');
                card.className = 'device-card';
                
                card.innerHTML = `
                    <div class="device-header">
                        <div class="device-ip">ğŸ“ ${ip}</div>
                        <div class="device-status ${device.connected ? 'status-online' : ''}">
                            ${device.connected ? 'â— åœ¨çº¿' : 'â—‹ ç¦»çº¿'}
                        </div>
                        <button class="remove-btn" onclick="removeDevice('${ip}')">Ã—</button>
                    </div>
                    
                    <div class="video-title ${!device.title ? 'idle' : ''}">
                        ${device.title || 'ç­‰å¾…æ’­æ”¾...'}
                        ${device.currentEpisode ? ` Â· ç¬¬${device.currentEpisode}é›†` : ''}
                    </div>
                    
                    ${device.title ? `
                        <div class="video-meta">
                            ${device.remarks ? `<div class="meta-item">ğŸ¬ ${device.remarks}</div>` : ''}
                            ${device.year ? `<div class="meta-item">ğŸ“… ${device.year}</div>` : ''}
                            ${device.area ? `<div class="meta-item">ğŸŒ ${device.area}</div>` : ''}
                        </div>
                        ${device.vodClass ? `<div class="info-row"><strong>åˆ†ç±»ï¼š</strong>${device.vodClass}</div>` : ''}
                        ${device.actor ? `<div class="info-row"><strong>æ¼”å‘˜ï¼š</strong>${device.actor.split(',').slice(0, 4).join('ã€')}</div>` : ''}
                        ${device.director ? `<div class="info-row"><strong>å¯¼æ¼”ï¼š</strong>${device.director}</div>` : ''}
                    ` : ''}
                    
                    <div style="margin-top: 15px;">
                        <button class="btn btn-primary" style="width: 100%; padding: 10px; font-size: 14px;" onclick="refreshDevice('${ip}')">
                            ğŸ”„ åˆ·æ–°æ’­æ”¾ä¿¡æ¯
                        </button>
                    </div>
                    
                    <div style="margin-top: 10px; font-size: 12px; color: #999;">
                        ${device.lastUpdate.toLocaleTimeString()}
                    </div>
                `;
                
                grid.appendChild(card);
            });
        }

        // åˆ·æ–°è®¾å¤‡ä¿¡æ¯ - ç®€åŒ–ç‰ˆ
        async function refreshDevice(ip) {
            console.log(`ğŸ”„ åˆ·æ–°è®¾å¤‡: ${ip}`);
            
            // æ£€æŸ¥åè®®
            if (window.location.protocol === 'file:') {
                showStatus('âŒ æœ¬åœ°æ–‡ä»¶æ¨¡å¼æ— æ³•åˆ·æ–°ï¼Œè¯·é€šè¿‡HTTPè®¿é—®', 'error');
                console.error('âŒ file:// åè®®ä¸æ”¯æŒåˆ·æ–°åŠŸèƒ½');
                setTimeout(() => showStatus('', 'info'), 3000);
                return;
            }
            
            try {
                const url = `http://${ip}:9978/action?do=refresh&type=detail`;
                
                // ç¬¬1æ¬¡åˆ·æ–°
                await fetch(url, { method: 'GET', mode: 'no-cors', cache: 'no-cache' });
                console.log(`âœ… ç¬¬1æ¬¡åˆ·æ–°`);
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // ç¬¬2æ¬¡åˆ·æ–°
                await fetch(url, { method: 'GET', mode: 'no-cors', cache: 'no-cache' });
                console.log(`âœ… ç¬¬2æ¬¡åˆ·æ–°`);
                
                showStatus(`âœ… å·²åˆ·æ–° ${ip}`, 'success');
                setTimeout(() => showStatus('', 'info'), 2000);
                
            } catch (error) {
                console.error(`âŒ åˆ·æ–°å¤±è´¥:`, error);
                showStatus(`âš ï¸ åˆ·æ–°å¤±è´¥`, 'error');
            }
        }

        // é¡µé¢å…³é—­æ—¶æ¸…ç†è¿æ¥
        window.addEventListener('beforeunload', () => {
            websockets.forEach(ws => ws.close());
        });

        // ç§»é™¤è®¾å¤‡
        function removeDevice(ip) {
            if (confirm(`ç¡®å®šç§»é™¤ ${ip}?`)) {
                if (websockets.has(ip)) {
                    websockets.get(ip).close();
                    websockets.delete(ip);
                }
                devices.delete(ip);
                renderDevices();
            }
        }

        // è·å–æœ¬æœºå±€åŸŸç½‘IPåœ°å€ - å¢å¼ºç‰ˆ
        async function getLocalIP() {
            return new Promise((resolve) => {
                try {
                    // åˆ›å»ºå¤šä¸ª STUN æœåŠ¡å™¨å°è¯•
                    const stunServers = [
                        "stun:stun.l.google.com:19302",
                        "stun:stun1.l.google.com:19302",
                        "stun:stun2.l.google.com:19302"
                    ];
                    
                    const pc = new RTCPeerConnection({
                        iceServers: stunServers.map(url => ({ urls: url }))
                    });
                    
                    pc.createDataChannel('');
                    pc.createOffer().then(offer => pc.setLocalDescription(offer));
                    
                    const timeout = setTimeout(() => {
                        pc.close();
                        console.log('âŒ WebRTC æ£€æµ‹è¶…æ—¶');
                        resolve(null);
                    }, 5000);
                    
                    let foundLocalIP = false;
                    let candidateCount = 0;
                    
                    pc.onicecandidate = (ice) => {
                        if (!ice || !ice.candidate || !ice.candidate.candidate) {
                            return;
                        }
                        
                        candidateCount++;
                        console.log(`ğŸ” ICEå€™é€‰ #${candidateCount}: ${ice.candidate.candidate}`);
                        
                        const match = ice.candidate.candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
                        if (match && match[1]) {
                            const fullIP = match[1];
                            const parts = fullIP.split('.');
                            const ipPrefix = `${parts[0]}.${parts[1]}.${parts[2]}`;
                            
                            console.log(`ğŸ“¡ æ£€æµ‹åˆ°IP: ${fullIP}`);
                            
                            const isPrivateIP = 
                                fullIP.startsWith('192.168.') ||
                                fullIP.startsWith('10.') ||
                                (fullIP.startsWith('172.') && parseInt(parts[1]) >= 16 && parseInt(parts[1]) <= 31);
                            
                            if (isPrivateIP && !foundLocalIP) {
                                foundLocalIP = true;
                                clearTimeout(timeout);
                                pc.close();
                                console.log(`âœ… æ£€æµ‹åˆ°å±€åŸŸç½‘æ®µ: ${ipPrefix}.x`);
                                resolve(ipPrefix);
                            } else if (!isPrivateIP) {
                                console.log(`â­ï¸ è·³è¿‡å…¬ç½‘IP: ${fullIP}`);
                            }
                        }
                    };
                    
                    pc.onicegatheringstatechange = () => {
                        console.log(`ğŸ”„ ICEçŠ¶æ€: ${pc.iceGatheringState}`);
                        if (pc.iceGatheringState === 'complete' && !foundLocalIP) {
                            clearTimeout(timeout);
                            pc.close();
                            console.log(`âŒ ICEæ”¶é›†å®Œæˆï¼Œä½†æœªæ‰¾åˆ°å±€åŸŸç½‘IP`);
                            resolve(null);
                        }
                    };
                    
                } catch (error) {
                    console.error('âŒ WebRTCé”™è¯¯:', error);
                    resolve(null);
                }
            });
        }

        // è‡ªåŠ¨æ‰«æ - è°ƒè¯•ç‰ˆ
        async function startScan() {
            if (isScanning) {
                showStatus('âš ï¸ æ­£åœ¨æ‰«æä¸­', 'info');
                return;
            }
            
            if (window.location.protocol === 'https:') {
                showStatus('âŒ è¯·ä½¿ç”¨HTTP', 'error');
                return;
            }
            
            isScanning = true;
            
            let ipRanges = [];
            const ipInput = document.getElementById('ipInput');
            const inputIP = ipInput.value.trim();
            
            // æ­¥éª¤1: ç¡®å®šæ‰«æç½‘æ®µ
            if (inputIP) {
                const ipPattern = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
                const match = inputIP.match(ipPattern);
                
                if (match) {
                    const prefix = `${match[1]}.${match[2]}.${match[3]}`;
                    ipRanges.push(prefix);
                    console.log(`ğŸ“ ä½¿ç”¨è¾“å…¥IP: ${inputIP} â†’ ç½‘æ®µ: ${prefix}.x`);
                    showStatus(`ğŸ” æ‰«æ ${prefix}.x`, 'info', 0);
                } else {
                    showStatus('âŒ IPæ ¼å¼é”™è¯¯', 'error');
                    isScanning = false;
                    return;
                }
            } else {
                // ä¸å°è¯•è‡ªåŠ¨æ£€æµ‹ï¼Œç›´æ¥ä½¿ç”¨é»˜è®¤ç½‘æ®µ
                ipRanges = ['192.168.0'];
                console.log('ğŸ’¡ ä½¿ç”¨é»˜è®¤ç½‘æ®µ: 192.168.0.x (å¤§éƒ¨åˆ†è·¯ç”±å™¨ä½¿ç”¨æ­¤ç½‘æ®µ)');
                showStatus('ğŸ” æ‰«æ 192.168.0.x', 'info', 0);
            }
            
            console.log('ğŸ” å¼€å§‹æ‰«æ 9978 ç«¯å£...');
            console.log(`ğŸ“¡ æ‰«æç½‘æ®µ: ${ipRanges.join(', ')}`);
            
            let foundCount = 0;
            let scannedCount = 0;
            const totalIPs = ipRanges.length * 254;
            
            for (const prefix of ipRanges) {
                for (let i = 1; i <= 254; i += 20) {
                    const batchStart = i;
                    const batchEnd = Math.min(i + 19, 254);
                    
                    const promises = [];
                    for (let j = i; j < i + 20 && j <= 254; j++) {
                        promises.push(checkDevice(`${prefix}.${j}`));
                    }
                    
                    const results = await Promise.all(promises);
                    
                    results.forEach(ip => {
                        if (ip) {
                            if (!devices.has(ip)) {
                                console.log(`âœ… å‘ç°: ${ip}`);
                                devices.set(ip, {
                                    ip: ip,
                                    connected: false,
                                    title: null,
                                    remarks: null,
                                    year: null,
                                    area: null,
                                    vodClass: null,
                                    actor: null,
                                    director: null,
                                    currentEpisode: null,
                                    lastUpdate: new Date()
                                });
                                connectWebSocket(ip);
                                foundCount++;
                                renderDevices();
                            }
                        }
                    });
                    
                    scannedCount += 20;
                    const progress = Math.min(Math.round((scannedCount / totalIPs) * 100), 100);
                    
                    if (foundCount > 0) {
                        showStatus(`âœ… å·²å‘ç° ${foundCount} å°è®¾å¤‡`, 'success', progress);
                    } else {
                        showStatus(`ğŸ” æ‰«æä¸­...`, 'info', progress);
                    }
                }
            }
            
            isScanning = false;
            
            if (foundCount > 0) {
                showStatus(`âœ… æ‰«æå®Œæˆï¼Œå…± ${foundCount} å°`, 'success', 100);
                console.log(`âœ… æ‰«æå®Œæˆï¼Œå…± ${foundCount} å°`);
            } else {
                showStatus('âŒ æœªå‘ç°è®¾å¤‡', 'error');
                console.log('âŒ æœªå‘ç°è®¾å¤‡');
            }
        }

        // æ£€æŸ¥è®¾å¤‡ - ä½¿ç”¨å’ŒconnectWebSocketç›¸åŒçš„æ–¹å¼
        async function checkDevice(ip) {
            return new Promise((resolve) => {
                let resolved = false;
                let ws = null;
                
                const timeout = setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        if (ws) {
                            try {
                                ws.close();
                            } catch (e) {}
                        }
                        resolve(null);
                    }
                }, 3000);
                
                try {
                    ws = new WebSocket(`ws://${ip}:9978`);
                    
                    ws.onopen = () => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeout);
                            console.log(`âœ… ${ip}`);
                            // å‘é€ä¸€æ¬¡å¿ƒè·³ç¡®è®¤è¿æ¥
                            try {
                                ws.send('HEARTBEAT');
                                setTimeout(() => {
                                    try {
                                        ws.close();
                                    } catch (e) {}
                                }, 100);
                            } catch (e) {
                                ws.close();
                            }
                            resolve(ip);
                        }
                    };

                    ws.onerror = (error) => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeout);
                            resolve(null);
                        }
                    };

                    ws.onclose = () => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeout);
                            resolve(null);
                        }
                    };
                    
                } catch (e) {
                    if (!resolved) {
                        resolved = true;
                        clearTimeout(timeout);
                        resolve(null);
                    }
                }
            });
        }

        // ç»‘å®šäº‹ä»¶
        document.getElementById('addBtn').addEventListener('click', addDevice);
        document.getElementById('scanBtn').addEventListener('click', startScan);
        document.getElementById('ipInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addDevice();
            }
        });

        // é¡µé¢å…³é—­æ¸…ç†
        window.addEventListener('beforeunload', () => {
            websockets.forEach(ws => ws.close());
        });
    </script>
</body>
</html>